<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinelec -  Stage - 2025</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --bg-color: #f8f9fa;
            --text-color: #333;
            --code-bg: #f1f1f1;
            --section-bg: white;
            --border-color: #ddd;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 2rem;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin-top: 0;
            font-size: 2.5rem;
        }

        h2 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-top: 40px;
        }

        h3 {
            color: var(--secondary-color);
            margin-top: 30px;
        }

        code {
            background-color: var(--code-bg);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.4;
            margin: 20px 0;
        }

        .section {
            background: var(--section-bg);
            padding: 25px;
            margin: 25px 0;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .highlight {
            background-color: rgba(231, 76, 60, 0.1);
            border-left: 4px solid var(--accent-color);
            padding: 15px;
            margin: 20px 0;
        }

        .diagram {
            margin: 25px auto;
            text-align: center;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .note {
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table, th, td {
            border: 1px solid var(--border-color);
        }

        th, td {
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: var(--primary-color);
            color: white;
        }

        tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .toc {
            background-color: var(--section-bg);
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        
        .toc ul {
            list-style-type: none;
            padding-left: 20px;
        }
        
        .toc li {
            margin-bottom: 8px;
        }
        
        .toc a {
            color: var(--secondary-color);
            text-decoration: none;
        }
        
        .toc a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        .mermaid {
            font-family: 'Fira Code', monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Sinelec -  Stage - 2025</h1>
            <p>Java, Spring Boot e MongoDB</p>
        </header>

        <div class="toc section">
            <h2>Indice</h2>
            <ul>
                <li><a href="#introduzione">1. Introduzione</a></li>
                <li><a href="#tecnologie">2. Tecnologie utilizzate</a></li>
                <li><a href="#concetti-spring">3. Concetti fondamentali di Spring Boot</a></li>
                <li><a href="#modelli">4. Modello dati</a></li>
                <li><a href="#repository">5. Repository</a></li>
                <li><a href="#service">6. Servizi</a></li>
                <li><a href="#controller">7. Controller REST</a></li>
                <li><a href="#driver">8. Pattern di design e gestione dei driver</a></li>
                <li><a href="#engine">9. Engine e Scheduling</a></li>
                <li><a href="#frontend">10. Dashboard e frontend</a></li>
                <li><a href="#esercizi">11. Esercizi pratici</a></li>
                <li><a href="#conclusioni">12. Conclusioni</a></li>
            </ul>
        </div>

        <div id="introduzione" class="section">
            <h2>1. Introduzione</h2>
            <p>Questo guida è strutturata per guidarvi attraverso lo sviluppo di un'applicazione completa per l'acquisizione di telemetrie da dispositivi su varie sorgenti, il salvataggio dei dati e la visualizzazione tramite dashboard.</p>
            <p>Al termine di questo percorso, avrete realizzato un'applicazione che può:</p>
            <ul>
                <li>Acquisire telemetrie da diverse sorgenti dati</li>
                <li>Salvare i valori letti in uno storico e mantenere l'ultimo stato</li>
                <li>Visualizzare le telemetrie tramite una dashboard</li>
                <li>Statistiche ed analisi dei dati acquisiti</li>
                <li>Configurare i dispositivi per le letture</li>
                <li>Gestire gli stati di allarme basati su condizioni configurabili</li>
            </ul>
            <div class="note">
                <p><strong>Nota:</strong> Questa guida è pensata per sviluppatori con conoscenze base di Java</p>
            </div>
        </div>

        <div id="tecnologie" class="section">
            <h2>2. Tecnologie utilizzate</h2>
            <h3>Java</h3>
            <p>Java è il linguaggio di programmazione principale utilizzato in questo progetto.</p>
            
            <h3>Spring Boot</h3>
            <p>Spring Boot è un framework che semplifica lo sviluppo di applicazioni basate su Spring. Offre configurazioni predefinite e strumenti che rendono più rapido lo sviluppo di applicazioni robuste.</p>
            <p>Utilizzeremo:</p>
            <ul>
                <li>Spring Data MongoDB</li>
                <li>Spring Web per i servizi REST</li>
                <li>Spring Scheduling per le operazioni periodiche</li>
            </ul>
            
            <h3>MongoDB</h3>
            <p>MongoDB è un database NoSQL orientato ai documenti che permette grande flessibilità nella gestione dei dati. È particolarmente adatto per l'archiviazione di telemetrie e dati di configurazione.</p>
        </div>

        <div id="concetti-spring" class="section">
            <h2>3. Concetti fondamentali di Spring Boot</h2>
            
            <h3>Inversion of Control (IoC) e Dependency Injection</h3>
            <p>L'IoC è un principio di design in cui il controllo del flusso del programma è invertito rispetto alla programmazione tradizionale. In Spring, questo si realizza attraverso la Dependency Injection (DI), dove gli oggetti ricevono le loro dipendenze anziché crearle.</p>
            <div class="highlight">
                <p>Esempio di Dependency Injection:</p>
                <pre><code>@Service
public class DeviceService {
    private final DeviceRepository deviceRepository;
    private final DeviceTypeRepository deviceTypeRepository;
    
    // Constructor Injection
    public DeviceService(DeviceRepository deviceRepository, DeviceTypeRepository deviceTypeRepository) {
        this.deviceRepository = deviceRepository;
        this.deviceTypeRepository = deviceTypeRepository;
    }
    
    // Field Injection (meno consigliata)
    // @Autowired
    // private DeviceRepository deviceRepository;
    
    // Setter Injection
    // private DeviceRepository deviceRepository;
    // @Autowired
    // public void setDeviceRepository(DeviceRepository deviceRepository) {
    //     this.deviceRepository = deviceRepository;
    // }
    
    public List<Device> findAllActiveDevices() {
        return deviceRepository.findByActive(true);
    }
}</code></pre>
                <p>In questo esempio, Spring inietta automaticamente le implementazioni di DeviceRepository e DeviceTypeRepository nel costruttore del DeviceService. Questo approccio è preferibile perché:</p>
                <ul>
                    <li>Rende esplicite le dipendenze</li>
                    <li>Facilita i test unitari</li>
                    <li>Garantisce l'immutabilità delle dipendenze</li>
                    <li>Evita problemi di dipendenze circolari</li>
                </ul>
            </div>
            
            <h3>Bean e loro annotazioni</h3>
            <p>I Bean sono oggetti gestiti dal container IoC di Spring. Li definiamo utilizzando diverse annotazioni:</p>
            <table>
                <tr>
                    <th>Annotazione</th>
                    <th>Descrizione</th>
                </tr>
                <tr>
                    <td>@Component</td>
                    <td>Indica un componente generico di Spring</td>
                </tr>
                <tr>
                    <td>@Service</td>
                    <td>Indica un servizio che contiene la logica di business</td>
                </tr>
                <tr>
                    <td>@Repository</td>
                    <td>Indica un componente che interagisce con il database</td>
                </tr>
                <tr>
                    <td>@Controller / @RestController</td>
                    <td>Indica un componente che gestisce le richieste HTTP</td>
                </tr>
                <tr>
                    <td>@Configuration</td>
                    <td>Indica una classe che definisce Bean</td>
                </tr>
            </table>
            
            <h3>REST API</h3>
            <p>REST (Representational State Transfer) è uno stile architetturale per la creazione di servizi web. In Spring, creiamo API REST utilizzando l'annotazione @RestController e definendo endpoint con @RequestMapping, @GetMapping, @PostMapping, ecc.</p>
            <div class="highlight">
                <p>Esempio di controller REST:</p>
                <pre><code>@RestController
@RequestMapping("/api/devices")
public class DeviceController {
    private final DeviceService deviceService;
    
    public DeviceController(DeviceService deviceService) {
        this.deviceService = deviceService;
    }
    
    @GetMapping
    public List<Device> getAllDevices() {
        return deviceService.findAll();
    }
    
    @GetMapping("/{id}")
    public Device getDeviceById(@PathVariable String id) {
        return deviceService.findById(id);
    }
}</code></pre>
            </div>
        </div>

        <div id="modelli" class="section">
            <h2>4. Modello dati</h2>
            <p>Definiamo i modelli per la nostra applicazione di telemetria basati sui requisiti.</p>
            
            <h3>Device (Dispositivo)</h3>
            <div class="highlight">
                <pre><code>@Document(collection = "devices")
public class Device {
    @Id
    private String id;
    private String name;
    private String description;
    private String location;
    private boolean active;
    private String deviceTypeId;
    private String datasourceId;
    
    // Configurazione specifica del dispositivo
    private Map<String, Object> configuration;
    
    // Getters e setters
}</code></pre>
            </div>
            
            <h3>DeviceType (Tipo di Dispositivo)</h3>
            <div class="highlight">
                <pre><code>@Document(collection = "deviceTypes")
public class DeviceType {
    @Id
    private String id;
    private String name;
    private String description;
    
    // Definizione dei segnali che questo tipo di dispositivo può gestire
    private List<Signal> signals;
    
    // Getters e setters
}

public class Signal {
    private String id;
    private String name;
    private String description;
    private SignalType type; // NUMERIC, STRING, BOOLEAN, etc.
    private Map<String, Object> configuration; // Configurazione specifica del segnale
    
    // Allarmi
    private boolean alarmEnabled;
    private AlarmCondition alarmCondition;
    
    // Getters e setters
}

public enum SignalType {
    NUMERIC, STRING, BOOLEAN, DATE, OBJECT
}

public class AlarmCondition {
    private AlarmOperator operator; // GT, LT, EQ, NEQ, etc.
    private Object threshold;
    private String message;
    
    // Getters e setters
}

public enum AlarmOperator {
    GT, LT, GTE, LTE, EQ, NEQ, CONTAINS, STARTS_WITH, ENDS_WITH
}</code></pre>
            </div>
            
            <h3>DeviceState (Stato del Dispositivo)</h3>
            <div class="highlight">
                <pre><code>@Document(collection = "deviceStates")
public class DeviceState {
    @Id
    private String id;
    private String deviceId;
    private Date timestamp;
    
    // Valori attuali dei segnali
    private Map<String, SignalState> signalStates;
    
    // Getters e setters
}

public class SignalState {
    private String signalId;
    private Object value;
    private Date timestamp;
    private boolean inAlarm;
    private String alarmMessage;
    
    // Getters e setters
}</code></pre>
            </div>
            
            <h3>Reading (Lettura)</h3>
            <div class="highlight">
                <pre><code>@Document(collection = "readings")
public class Reading {
    @Id
    private String id;
    private String deviceId;
    private String signalId;  // ID del segnale specifico
    private Date timestamp;
    private Object value;     // Valore del segnale
    
    // Getters e setters
}</code></pre>
                <p>Una lettura rappresenta il valore di un singolo segnale per un dispositivo specifico in un determinato momento.</p>
                <ul>
                    <li><strong>deviceId</strong>: L'identificativo del dispositivo da cui proviene la lettura</li>
                    <li><strong>signalId</strong>: L'identificativo del segnale specifico letto</li>
                    <li><strong>timestamp</strong>: Il momento esatto in cui è stata effettuata la lettura</li>
                    <li><strong>value</strong>: Il valore effettivo letto (può essere di vari tipi in base al SignalType)</li>
                </ul>
            </div>
            
            <h3>Datasource (Sorgente Dati)</h3>
            <div class="highlight">
                <pre><code>@Document(collection = "datasources")
public class Datasource {
    @Id
    private String id;
    private String name;
    private String description;
    private String driverId; // Identifica il tipo di driver da utilizzare
    private boolean active;
    
    // Configurazione della sorgente dati
    private Map<String, Object> configuration;
    
    // Getters e setters
}</code></pre>
            </div>
            
            <div class="note">
                <p><strong>Nota sulle annotazioni MongoDB:</strong></p>
                <ul>
                    <li><code>@Document</code>: Indica che la classe rappresenta un documento MongoDB</li>
                    <li><code>@Id</code>: Identifica il campo ID del documento</li>
                    <li><code>@Field</code>: Può essere usato per specificare il nome del campo nel documento</li>
                    <li><code>@Indexed</code>: Crea un indice sul campo per ottimizzare le query</li>
                </ul>
            </div>
        </div>

        <div id="repository" class="section">
            <h2>5. Repository</h2>
            <p>I repository di Spring Data ci permettono di interagire con il database MongoDB in modo semplice e dichiarativo. Spring Data implementa automaticamente metodi di query basati sui nomi dei metodi definiti nelle interfacce repository.</p>
            
            <h3>DeviceRepository</h3>
            <div class="highlight">
                <pre><code>@Repository
public interface DeviceRepository extends MongoRepository<Device, String> {
    List<Device> findByActive(boolean active);
    List<Device> findByDeviceTypeId(String deviceTypeId);
    List<Device> findByDatasourceId(String datasourceId);
    Optional<Device> findByName(String name);
    
    // Query più complesse con @Query
    @Query("{'location': ?0, 'active': true}")
    List<Device> findActiveDevicesByLocation(String location);
    
    // Query di aggregazione per statistiche
    @Aggregation(pipeline = {
        "{ $match: { 'active': true } }",
        "{ $group: { '_id': '$deviceTypeId', 'count': { $sum: 1 } } }"
    })
    List<DeviceTypeCount> countByDeviceType();
}</code></pre>
                <p>Questa interfaccia estende MongoRepository che fornisce metodi CRUD di base e paginazione. I metodi personalizzati sono generati automaticamente in base alla convenzione dei nomi:</p>
                <ul>
                    <li><strong>findByActive</strong>: Trova tutti i dispositivi con stato attivo/inattivo</li>
                    <li><strong>findByDeviceTypeId</strong>: Trova dispositivi di un certo tipo</li>
                    <li><strong>findByDatasourceId</strong>: Trova dispositivi collegati a una specifica sorgente dati</li>
                    <li><strong>findByName</strong>: Trova un dispositivo per nome (restituisce Optional per gestire il caso in cui non esista)</li>
                </ul>
                <p>Le annotazioni @Query e @Aggregation ci permettono di definire query MongoDB complesse quando la convenzione dei nomi non è sufficiente.</p>
            </div>
            
            <h3>DeviceTypeRepository</h3>
            <div class="highlight">
                <pre><code>@Repository
public interface DeviceTypeRepository extends MongoRepository<DeviceType, String> {
    Optional<DeviceType> findByName(String name);
}</code></pre>
            </div>
            
            <h3>DeviceStateRepository</h3>
            <div class="highlight">
                <pre><code>@Repository
public interface DeviceStateRepository extends MongoRepository<DeviceState, String> {
    Optional<DeviceState> findTopByDeviceIdOrderByTimestampDesc(String deviceId);
    List<DeviceState> findByDeviceIdAndTimestampBetween(String deviceId, Date start, Date end);
}</code></pre>
            </div>
            
            <h3>ReadingRepository</h3>
            <div class="highlight">
                <pre><code>@Repository
public interface ReadingRepository extends MongoRepository<Reading, String> {
    List<Reading> findByDeviceId(String deviceId);
    List<Reading> findByDeviceIdAndTimestampBetween(String deviceId, Date start, Date end);
    
    @Query("{'deviceId': ?0, 'values.?1': {$exists: true}}")
    List<Reading> findByDeviceIdAndSignalId(String deviceId, String signalId);
}</code></pre>
            </div>
            
            <h3>DatasourceRepository</h3>
            <div class="highlight">
                <pre><code>@Repository
public interface DatasourceRepository extends MongoRepository<Datasource, String> {
    List<Datasource> findByActive(boolean active);
    List<Datasource> findByDriverId(String driverId);
}</code></pre>
            </div>
            
            <div class="note">
                <p><strong>Nota su Spring Data:</strong> Spring Data offre metodi automatici per le operazioni CRUD e supporta la creazione di metodi di query con nomi descrittivi. Per query più complesse, possiamo utilizzare l'annotazione @Query.</p>
            </div>
        </div>

        <div id="service" class="section">
            <h2>6. Servizi</h2>
            <p>I servizi contengono la logica di business e fungono da intermediari tra i controller e i repository. Seguendo il principio di separazione dei livelli:</p>
            
            <div class="diagram">
                <p style="background-color: #ddd; padding: 10px; text-align: center;">
                    CONTROLLER → SERVICE → REPOSITORY
                </p>
            </div>
            
            <h3>DeviceService</h3>
            <div class="highlight">
                <pre><code>@Service
public class DeviceService {
    private final DeviceRepository deviceRepository;
    private final DeviceTypeRepository deviceTypeRepository;
    
    public DeviceService(DeviceRepository deviceRepository, DeviceTypeRepository deviceTypeRepository) {
        this.deviceRepository = deviceRepository;
        this.deviceTypeRepository = deviceTypeRepository;
    }
    
    public List<Device> findAll() {
        return deviceRepository.findAll();
    }
    
    public Device findById(String id) {
        return deviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Device not found with id: " + id));
    }
    
    public Device save(Device device) {
        // Validare che il deviceType esista
        deviceTypeRepository.findById(device.getDeviceTypeId())
                .orElseThrow(() -> new ResourceNotFoundException("DeviceType not found with id: " + device.getDeviceTypeId()));
        
        return deviceRepository.save(device);
    }
    
    public void deleteById(String id) {
        deviceRepository.deleteById(id);
    }
    
    // Altri metodi di business logic
}</code></pre>
            </div>
            
            <p>Implementeremo servizi simili per DeviceType, DeviceState, Reading e Datasource. Ogni servizio conterrà:</p>
            <ul>
                <li>Metodi CRUD base</li>
                <li>Logica di business specifica</li>
                <li>Validazioni e controlli</li>
            </ul>
            
            <div class="note">
                <p><strong>Nota sull'eccezione personalizzata:</strong> È buona pratica creare eccezioni personalizzate come ResourceNotFoundException per gestire in modo uniforme gli errori.</p>
                <pre><code>public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}</code></pre>
            </div>
        </div>

        <div id="controller" class="section">
            <h2>7. Controller REST</h2>
            <p>I controller REST definiscono gli endpoint dell'API che espongono i servizi dell'applicazione.</p>
            
            <h3>DeviceController</h3>
            <div class="highlight">
                <pre><code>@RestController
@RequestMapping("/api/devices")
public class DeviceController {
    private final DeviceService deviceService;
    
    public DeviceController(DeviceService deviceService) {
        this.deviceService = deviceService;
    }
    
    @GetMapping
    public ResponseEntity<List<Device>> getAllDevices() {
        return ResponseEntity.ok(deviceService.findAll());
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<Device> getDeviceById(@PathVariable String id) {
        return ResponseEntity.ok(deviceService.findById(id));
    }
    
    @PostMapping
    public ResponseEntity<Device> createDevice(@RequestBody Device device) {
        return ResponseEntity.status(HttpStatus.CREATED).body(deviceService.save(device));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<Device> updateDevice(@PathVariable String id, @RequestBody Device device) {
        device.setId(id);
        return ResponseEntity.ok(deviceService.save(device));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteDevice(@PathVariable String id) {
        deviceService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
    
    // Altri endpoint
}</code></pre>
            </div>
            
            <p>Ogni entità (DeviceType, DeviceState, Datasource) avrà il proprio controller con endpoint simili.</p>
            
            <div class="note">
                <p><strong>Nota sulle annotazioni REST:</strong></p>
                <ul>
                    <li><code>@RestController</code>: Combina @Controller e @ResponseBody</li>
                    <li><code>@RequestMapping</code>: Definisce il path base</li>
                    <li><code>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping</code>: Shorthand per i metodi HTTP</li>
                    <li><code>@PathVariable</code>: Estrae variabili dal path</li>
                    <li><code>@RequestBody</code>: Converte il corpo della richiesta in un oggetto</li>
                    <li><code>@RequestParam</code>: Estrae parametri dalla query string</li>
                </ul>
            </div>
        </div>

        <div id="driver" class="section">
            <h2>8. Pattern di design e gestione dei driver</h2>
            <p>Implementeremo diversi pattern di design per rendere l'applicazione modulare e manutenibile.</p>
            
            <h3>Pattern Factory</h3>
            <p>Utilizzeremo il pattern Factory per creare driver diversi in base al tipo di sorgente dati.</p>
            
            <div class="highlight">
                <p>Interfaccia Driver:</p>
                <pre><code>public interface Driver {
    /**
     * Restituisce l'identificatore univoco di questo tipo di driver
     */
    String getId();
    
    void initialize(Datasource datasource);
    void connect() throws DriverException;
    void disconnect();
    Reading[] read(Device[] devices) throws DriverException;
    boolean isConnected();
}</code></pre>
            </div>
            
            <div class="highlight">
                <p>Implementazione di driver specifici:</p>
                <pre><code>@Component
public class OpcUaDriver implements Driver {
    private Datasource datasource;
    private boolean connected;
    // Altre proprietà specifiche per OPC UA
    
    @Override
    public String getId() {
        return "opcua";
    }
    
    @Override
    public void initialize(Datasource datasource) {
        this.datasource = datasource;
        // Inizializzazione specifica per OPC UA
    }
    
    @Override
    public void connect() throws DriverException {
        try {
            // Logica per la connessione OPC UA
            this.connected = true;
        } catch (Exception e) {
            throw new DriverException("Failed to connect to OPC UA server", e);
        }
    }
    
    @Override
    public void disconnect() {
        // Logica per la disconnessione
        this.connected = false;
    }
    
    @Override
    public Reading[] read(Device[] devices) throws DriverException {
        if (!connected) {
            throw new DriverException("Driver not connected");
        }
        
        try {
            List<Reading> readingsList = new ArrayList<>();
            
            // Iterare su tutti i dispositivi
            for (Device device : devices) {
                DeviceType deviceType = getDeviceType(device.getDeviceTypeId());
                
                // Per ogni dispositivo, iteriamo sui suoi segnali
                for (Signal signal : deviceType.getSignals()) {
                    // Verifichiamo se questo segnale è configurato per questo dispositivo
                    if (isSignalConfiguredForDevice(signal.getId(), device)) {
                        // Costruiamo il path OPC UA o altra informazione necessaria per leggere questo segnale
                        String nodePath = buildNodePath(device, signal);
                        
                        // Leggere il valore dal server OPC UA
                        Object value = readValueFromOpcUa(nodePath);
                        
                        // Creare una nuova lettura
            Reading reading = new Reading();
            reading.setDeviceId(device.getId());
                        reading.setSignalId(signal.getId());
            reading.setTimestamp(new Date());
                        reading.setValue(value);
                        
                        readingsList.add(reading);
                    }
                }
            }
            
            // Conversione da List a array
            return readingsList.toArray(new Reading[0]);
        } catch (Exception e) {
            throw new DriverException("Failed to read from OPC UA server", e);
        }
    }
    
    @Override
    public boolean isConnected() {
        return connected;
    }
    
    // Metodi helper per la lettura
    private DeviceType getDeviceType(String deviceTypeId) {
        // Recuperare il device type dal repository
        return null; // Da implementare
    }
    
    private boolean isSignalConfiguredForDevice(String signalId, Device device) {
        // Verificare se il segnale è configurato per questo dispositivo
        return true; // Da implementare
    }
    
    private String buildNodePath(Device device, Signal signal) {
        // Costruire il path per il nodo OPC UA
        return ""; // Da implementare
    }
    
    private Object readValueFromOpcUa(String nodePath) {
        // Leggere il valore dal server OPC UA
        return null; // Da implementare
    }
}</code></pre>
        </div>

            <div class="highlight">
                <p>Factory per i driver:</p>
                <pre><code>@Service
public class DriverFactory {
    private static final Logger logger = LoggerFactory.getLogger(DriverFactory.class);
    
    private final Map<String, String> driverBeanMap;
    private final ApplicationContext applicationContext;
    
    /**
     * Costruttore che inietta automaticamente tutti i bean che implementano l'interfaccia Driver
     * e l'ApplicationContext per creare nuove istanze
     */
    @Autowired
    public DriverFactory(List<Driver> availableDrivers, ApplicationContext applicationContext) {
        this.driverBeanMap = new HashMap<>();
        this.applicationContext = applicationContext;
        
        // Mappare gli ID dei driver con i nomi dei bean
        for (Driver driver : availableDrivers) {
            driverBeanMap.put(driver.getId().toLowerCase(), driver.getClass().getName());
            logger.info("Registered driver type: {} - {}", driver.getId(), driver.getClass().getName());
        }
    }
    
    /**
     * Crea una nuova istanza di driver basata sull'ID
     * I driver non sono singleton perché hanno stato (datasource, connection)
     */
    public Driver createDriver(String driverId) {
        String driverClassName = driverBeanMap.get(driverId.toLowerCase());
        if (driverClassName == null) {
            throw new IllegalArgumentException("Unsupported driver type: " + driverId);
        }
        
        try {
            // Crea una nuova istanza del driver usando l'ApplicationContext
            // Questo garantisce che tutte le dipendenze del driver siano correttamente iniettate
            Class<?> driverClass = Class.forName(driverClassName);
            return (Driver) applicationContext.getBean(driverClass);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException("Driver class not found: " + driverClassName, e);
        }
    }
}</code></pre>

                <p>Con questo approccio, ogni driver implementa il metodo <code>getId()</code> per identificarsi in modo univoco. 
                La <code>DriverFactory</code> utilizza l'<code>ApplicationContext</code> di Spring per creare nuove istanze di driver, 
                garantendo che tutte le dipendenze siano correttamente iniettate mentre ogni istanza mantiene il proprio stato.</p>
            </div>
            
            <h3>Bean Stateful e Stateless in Spring</h3>
            <div class="note">
                <p>In Spring, i bean possono essere configurati con diversi scope che determinano il loro ciclo di vita e stato:</p>
                
                <h4>Bean Stateless (Singleton)</h4>
                <ul>
                    <li><strong>Scope</strong>: <code>@Scope("singleton")</code> - default se non specificato</li>
                    <li><strong>Caratteristiche</strong>: Una sola istanza del bean viene creata per l'intero ApplicationContext</li>
                    <li><strong>Uso</strong>: Servizi, repository, factory che non mantengono stato dell'applicazione</li>
                    <li><strong>Vantaggi</strong>: Migliori performance, minor consumo di memoria</li>
                    <li><strong>Svantaggi</strong>: Non adatto per componenti che devono mantenere stato per ogni client</li>
                    <li><strong>Esempio</strong>: <code>DeviceService</code>, <code>DriverFactory</code></li>
                </ul>
                
                <h4>Bean Stateful (Prototype)</h4>
                <ul>
                    <li><strong>Scope</strong>: <code>@Scope("prototype")</code></li>
                    <li><strong>Caratteristiche</strong>: Una nuova istanza viene creata ogni volta che il bean viene richiesto</li>
                    <li><strong>Uso</strong>: Componenti che mantengono stato, come i driver di connessione</li>
                    <li><strong>Vantaggi</strong>: Isolamento dello stato per ogni istanza</li>
                    <li><strong>Svantaggi</strong>: Maggior consumo di memoria, potrebbero essere necessari meccanismi di cleanup espliciti</li>
                    <li><strong>Esempio</strong>: <code>Driver</code> - Ogni connessione a una sorgente dati ha il suo stato</li>
                </ul>
                
                <pre><code>@Component
@Scope("prototype")  // Crea una nuova istanza ogni volta che viene richiesto
public class OpcUaDriver implements Driver {
    // Implementazione...
}</code></pre>
                
                <h4>Altri scope in Spring</h4>
                <ul>
                    <li><strong>request</strong>: Una istanza per ogni richiesta HTTP</li>
                    <li><strong>session</strong>: Una istanza per ogni sessione HTTP</li>
                    <li><strong>application</strong>: Una istanza per ogni ServletContext</li>
                    <li><strong>websocket</strong>: Una istanza per ogni WebSocket</li>
                </ul>
                
                <p>Nel nostro caso dei driver, è fondamentale usare lo scope <code>prototype</code> poiché ogni driver mantiene uno stato specifico per la connessione a una particolare sorgente dati. Questo impedisce che più sorgenti dati condividano lo stesso stato di connessione, causando potenziali conflitti.</p>
            </div>
        </div>

        <div id="engine" class="section">
            <h2>9. Engine e Scheduling</h2>
            <p>L'Engine di telemetria è il cuore del sistema di acquisizione dati. Si occupa di inizializzare i driver, gestire le connessioni alle sorgenti dati e schedulare la lettura periodica dei dispositivi.</p>
            
            <h3>Configurazione dello Scheduling</h3>
            <div class="highlight">
                <pre><code>@Configuration
@EnableScheduling
public class SchedulingConfig {
    
    @Bean
    public TaskScheduler taskScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(10); // Numero di thread per esecuzioni parallele
        scheduler.setThreadNamePrefix("telemetry-scheduler-");
        scheduler.setErrorHandler(throwable -> 
            logger.error("Error in scheduled task", throwable));
        return scheduler;
    }
}</code></pre>
                <p>Questa configurazione abilita lo scheduling in Spring e configura un pool di thread per eseguire operazioni pianificate in parallelo.</p>
            </div>
            
            <h3>Architettura dell'Engine</h3>
            <p>L'Engine di telemetria segue un'architettura modulare:</p>
            <ul>
                <li><strong>Inizializzazione</strong>: Carica le sorgenti dati attive e inizializza i driver</li>
                <li><strong>Polling</strong>: Esegue letture periodiche dai dispositivi raggruppati per sorgente dati</li>
                <li><strong>Elaborazione</strong>: Salva le letture e aggiorna gli stati dei dispositivi</li>
                <li><strong>Monitoraggio</strong>: Verifica le condizioni di allarme</li>
                </ul>
            
            <p>Il ciclo di vita dell'Engine è gestito da Spring attraverso le annotazioni @PostConstruct e @PreDestroy:</p>
            <ul>
                <li><strong>@PostConstruct</strong>: Eseguito dopo l'inizializzazione del bean, utilizzato per caricare le sorgenti dati e inizializzare i driver</li>
                <li><strong>@PreDestroy</strong>: Eseguito prima della distruzione del bean, utilizzato per disconnettere ordinatamente i driver</li>
            </ul>
            
            <h3>Gestione delle Eccezioni</h3>
            <p>L'Engine implementa una robusta gestione delle eccezioni per garantire che un errore in un dispositivo o sorgente dati non comprometta l'intero sistema:</p>
            <ul>
                <li>Errori di connessione sono loggati e non impediscono l'inizializzazione di altre sorgenti</li>
                <li>Errori durante la lettura sono catturati per singolo dispositivo/sorgente</li>
                <li>Il sistema tenta automaticamente di riconnettersi alle sorgenti fallite</li>
            </ul>
        </div>

        <div id="frontend" class="section">
            <h2>10. Dashboard e frontend</h2>
            <p>Per la dashboard di visualizzazione delle telemetrie, possiamo implementare un frontend utilizzando tecnologie come:</p>
            <ul>
                <li>Thymeleaf (integrato con Spring Boot)</li>
                <li>Angular, React o Vue.js (per applicazioni più complesse)</li>
            </ul>
            
            <p>La dashboard dovrebbe includere:</p>
            <ul>
                <li>Vista generale dei dispositivi e del loro stato</li>
                <li>Vista dettagliata di un singolo dispositivo con i suoi segnali</li>
                <li>Grafici per visualizzare l'andamento dei valori nel tempo</li>
                <li>Sistema di allarmi e notifiche</li>
                <li>Configurazione dei dispositivi e dei segnali</li>
            </ul>
            
            <p>Un esempio di controller per la visualizzazione:</p>
            <div class="highlight">
                <pre><code>@Controller
@RequestMapping("/dashboard")
public class DashboardController {
    private final DeviceService deviceService;
    private final DeviceStateService deviceStateService;
    
    public DashboardController(DeviceService deviceService, DeviceStateService deviceStateService) {
        this.deviceService = deviceService;
        this.deviceStateService = deviceStateService;
    }
    
    @GetMapping
    public String dashboard(Model model) {
        List<Device> devices = deviceService.findAll();
        model.addAttribute("devices", devices);
        return "dashboard/index";
    }
    
    @GetMapping("/device/{id}")
    public String deviceDetails(@PathVariable String id, Model model) {
        Device device = deviceService.findById(id);
        DeviceState state = deviceStateService.getCurrentState(id);
        
        model.addAttribute("device", device);
        model.addAttribute("state", state);
        
        return "dashboard/device-details";
    }
}</code></pre>
            </div>
        </div>

        <div id="esercizi" class="section">
            <h2>11. Esercizi pratici</h2>
            <p>Durante il corso, gli studenti dovranno completare una serie di esercizi pratici:</p>
            
            <ol>
                <li>Configurare un progetto Spring Boot con MongoDB</li>
                <li>Implementare il modello dati e il livello di accesso ai dati (repository)</li>
                <li>Creare API REST per la gestione dei dispositivi e delle configurazioni</li>
                <li>Implementare un driver di esempio per una sorgente dati (es. simulazione)</li>
                <li>Integrare il driver con il sistema di polling</li>
                <li>Implementare la logica di allarme</li>
                <li>Creare una dashboard per visualizzare i dati</li>
                <li>Estendere l'applicazione con funzionalità aggiuntive (es. notifiche, export dati)</li>
            </ol>
        </div>

        <div id="conclusioni" class="section">
            <h2>12. Conclusioni</h2>
            
            <p>Al temrine del progetto si raggiungera una buona padronanza di:</p>
            <ul>
                <li>I principi fondamentali di Spring Boot</li>
                <li>La progettazione di API REST</li>
                <li>L'utilizzo di Spring Data con MongoDB</li>
                <li>Pattern di progettazione come Factory</li>
                <li>Implementazione di job schedulati</li>
                <li>Sviluppo di sistemi modulari e estensibili</li>
                <li>Creazione di dashboard per la visualizzazione dei dati</li>
            </ul>
        </div>

        <div id="diagrammi" class="section">
            <h2>4.1 Diagrammi del modello</h2>
            
            <h3>Diagramma Entità-Relazione (E/R)</h3>
            <div class="diagram">
                <div class="mermaid">
                    erDiagram
                    DeviceType ||--o{ Device : "è di tipo"
                    Device }|--|| Datasource : "utilizza"
                    Device ||--o{ DeviceState : "ha"
                    DeviceType ||--o{ Signal : "definisce"
                    Device ||--o{ Hystoric : "produce"
                    Datasource ||--o{ Hystoric : "fornisce"
                    
                    DeviceType {
                        string id PK
                        string name
                        string description
                    }
                    
                    Device {
                        string id PK
                        string name
                        string description
                        string location
                        boolean active
                        string deviceTypeId FK
                        string datasourceId FK
                        object configuration
                    }
                    
                    Datasource {
                        string id PK
                        string name
                        string description
                        string driverId
                        boolean active
                        object configuration
                    }
                    
                    DeviceState {
                        string id PK
                        string deviceId FK
                        date timestamp
                        object signalStates
                    }
                    
                    Hystoric {
                        string id PK
                        string deviceId FK
                        string signalId
                        date timestamp
                        object value
                    }
        </div>
    </div>
            
            <h3>Diagramma delle Classi</h3>
            <div class="diagram">
                <pre>
+------------------+    +-------------------+    +------------------+
| DeviceRepository |    | DeviceService     |    | DeviceController |
+------------------+    +-------------------+    +------------------+
| findByActive     |    | deviceRepository  |    | deviceService    |
| findByName       |<---| findAll           |<---| getAllDevices    |
| findById         |    | findById          |    | getDeviceById    |
| save             |    | save              |    | createDevice     |
| deleteById       |    | deleteById        |    | updateDevice     |
+------------------+    +-------------------+    | deleteDevice     |
                                                 +------------------+
                                                 
+------------------+    +-------------------+    
| Driver Interface |    | TelemetryEngine   |    
+------------------+    +-------------------+    
| getId            |    | datasourceRepo    |    
| initialize       |    | deviceRepo        |    
| connect          |    | readingRepo       |    
| disconnect       |    | driverFactory     |    
| read             |<---| activeDrivers     |    
| isConnected      |    | initialize        |    
+------------------+    | shutdown          |    
        ^               | pollDevices       |    
        |               +-------------------+    
        |                        |               
        |                        v               
+------------------+    +-------------------+    
| OpcUaDriver      |    | DriverFactory     |    
+------------------+    +-------------------+    
| datasource       |    | driverBeanMap     |    
| connected        |    | applicationContext|    
| getId            |    | createDriver      |    
| initialize       |    +-------------------+    
| connect          |            ^               
| disconnect       |            |               
| read             |            |               
| isConnected      |    +-------------------+    
+------------------+    | ModbusDriver      |    
                        +-------------------+
                        | ...               |
                        +-------------------+
                </pre>
            </div>

            <h3>Architettura del sistema a componenti</h3>
            <div class="diagram">
                <div class="mermaid">
                    flowchart TD
                        subgraph Client
                        UI[Frontend/Dashboard]
                        end
                        
                        subgraph API
                        REST[REST Controllers]
                        end
                        
                        subgraph Business
                        Services[Service Layer]
                        Engine[Telemetry Engine]
                        end
                        
                        subgraph Data
                        Repositories[Repository Layer]
                        MongoDB[(MongoDB)]
                        end
                        
                        subgraph Telemetry
                        Drivers[Driver Components]
                        DataSources[External Data Sources]
                        end
                        
                        UI -->|HTTP Requests| REST
                        REST -->|Method Calls| Services
                        Services -->|CRUD Operations| Repositories
                        Repositories -->|Queries/Updates| MongoDB
                        Engine -->|Uses| Services
                        Engine -->|Creates| Drivers
                        Drivers -->|Connects to| DataSources
                </div>
            </div>
        </div>
    </div>

    <script>
        // Inizializzazione di Mermaid con tema chiaro
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: { useMaxWidth: true },
            er: { useMaxWidth: true },
            classdiagram: { useMaxWidth: true }
        });
    </script>
</body>
</html>
